





:class:`cyclic_expansion`
=========================

.. py:class:: ansys.dpf.core.operators.result.cyclic_expansion.cyclic_expansion(time_scoping=None, mesh_scoping=None, fields_container=None, harmonic_index=None, bool_rotate_to_global=None, map_size_scoping_out=None, normalization_factor=None, merge_stages=None, cyclic_support=None, sectors_to_expand=None, phi=None, config=None, server=None)

   Bases: :py:obj:`ansys.dpf.core.dpf_operator.Operator`


   Expand cyclic results from a fieldsContainer for given sets, sectors
   and scoping (optionals).

   :param time_scoping:
   :type time_scoping: Scoping, optional
   :param mesh_scoping:
   :type mesh_scoping: ScopingsContainer or Scoping, optional
   :param fields_container: Field container with the base and duplicate
                            sectors
   :type fields_container: FieldsContainer
   :param harmonic_index:
   :type harmonic_index: int, optional
   :param bool_rotate_to_global: Default is true
   :type bool_rotate_to_global: bool, optional
   :param map_size_scoping_out: Map provider by scoping adapter
   :type map_size_scoping_out: optional
   :param normalization_factor:
   :type normalization_factor: float, optional
   :param merge_stages:
   :type merge_stages: bool, optional
   :param cyclic_support:
   :type cyclic_support: CyclicSupport
   :param sectors_to_expand: Sectors to expand (start at 0), for
                             multistage: use scopings container
                             with 'stage' label.
   :type sectors_to_expand: Scoping or ScopingsContainer, optional
   :param phi: Angle phi in degrees (default value 0.0)
   :type phi: float, optional

   :returns: **fields_container** -- Fieldscontainer filled in
   :rtype: FieldsContainer

   .. rubric:: Examples

   >>> from ansys.dpf import core as dpf

   >>> # Instantiate operator
   >>> op = dpf.operators.result.cyclic_expansion()

   >>> # Make input connections
   >>> my_time_scoping = dpf.Scoping()
   >>> op.inputs.time_scoping.connect(my_time_scoping)
   >>> my_mesh_scoping = dpf.ScopingsContainer()
   >>> op.inputs.mesh_scoping.connect(my_mesh_scoping)
   >>> my_fields_container = dpf.FieldsContainer()
   >>> op.inputs.fields_container.connect(my_fields_container)
   >>> my_harmonic_index = int()
   >>> op.inputs.harmonic_index.connect(my_harmonic_index)
   >>> my_bool_rotate_to_global = bool()
   >>> op.inputs.bool_rotate_to_global.connect(my_bool_rotate_to_global)
   >>> my_map_size_scoping_out = dpf.()
   >>> op.inputs.map_size_scoping_out.connect(my_map_size_scoping_out)
   >>> my_normalization_factor = float()
   >>> op.inputs.normalization_factor.connect(my_normalization_factor)
   >>> my_merge_stages = bool()
   >>> op.inputs.merge_stages.connect(my_merge_stages)
   >>> my_cyclic_support = dpf.CyclicSupport()
   >>> op.inputs.cyclic_support.connect(my_cyclic_support)
   >>> my_sectors_to_expand = dpf.Scoping()
   >>> op.inputs.sectors_to_expand.connect(my_sectors_to_expand)
   >>> my_phi = float()
   >>> op.inputs.phi.connect(my_phi)

   >>> # Instantiate operator and connect inputs in one line
   >>> op = dpf.operators.result.cyclic_expansion(
   ...     time_scoping=my_time_scoping,
   ...     mesh_scoping=my_mesh_scoping,
   ...     fields_container=my_fields_container,
   ...     harmonic_index=my_harmonic_index,
   ...     bool_rotate_to_global=my_bool_rotate_to_global,
   ...     map_size_scoping_out=my_map_size_scoping_out,
   ...     normalization_factor=my_normalization_factor,
   ...     merge_stages=my_merge_stages,
   ...     cyclic_support=my_cyclic_support,
   ...     sectors_to_expand=my_sectors_to_expand,
   ...     phi=my_phi,
   ... )

   >>> # Get output data
   >>> result_fields_container = op.outputs.fields_container()




.. py:currentmodule:: cyclic_expansion

Overview
--------

.. tab-set::




   .. tab-item:: Properties

      .. list-table::
          :header-rows: 0
          :widths: auto

          * - :py:attr:`~inputs`
            - Enables to connect inputs to the operator
          * - :py:attr:`~outputs`
            - Enables to get outputs of the operator by evaluating it



   .. tab-item:: Static methods

      .. list-table::
          :header-rows: 0
          :widths: auto

          * - :py:attr:`~default_config`
            - Returns the default config of the operator.





Import detail
-------------

.. code-block:: python

    from ansys.dpf.core.operators.result.cyclic_expansion import cyclic_expansion

Property detail
---------------

.. py:property:: inputs

   Enables to connect inputs to the operator

   :returns: **inputs**
   :rtype: InputsCyclicExpansion

.. py:property:: outputs

   Enables to get outputs of the operator by evaluating it

   :returns: **outputs**
   :rtype: OutputsCyclicExpansion




Method detail
-------------

.. py:method:: default_config(server=None)
   :staticmethod:


   Returns the default config of the operator.

   This config can then be changed to the user needs and be used to
   instantiate the operator. The Configuration allows to customize
   how the operation will be processed by the operator.

   :param server: Server with channel connected to the remote or local instance. When
                  ``None``, attempts to use the global server.
   :type server: server.DPFServer, optional





