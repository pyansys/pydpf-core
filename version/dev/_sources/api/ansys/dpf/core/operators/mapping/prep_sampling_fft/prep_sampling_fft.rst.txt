





:class:`prep_sampling_fft`
==========================

.. py:class:: ansys.dpf.core.operators.mapping.prep_sampling_fft.prep_sampling_fft(time_freq_support=None, cutoff_frequency=None, number_sampling_point=None, config=None, server=None)

   Bases: :py:obj:`ansys.dpf.core.dpf_operator.Operator`


   Prepare time sampling optimum for FFT computation and expected
   frequencies in output.

   :param time_freq_support: Initial time domain timefreqsupport.
   :type time_freq_support: TimeFreqSupport
   :param cutoff_frequency: Cutoff frequency. in this case, number of
                            points is calculated computing
                            (time_range * cutoff_freq * 2) and
                            taking the next power of 2 (optimum
                            for fft calculation).
   :type cutoff_frequency: float, optional
   :param number_sampling_point: For number of sampling point (calculation
                                 with cutoff_frequency is ignored).
   :type number_sampling_point: int, optional

   :returns: * **time_tfs_sampled** (*TimeFreqSupport*) -- Optimum sampled time domain timefreqsupport.
             * **freq_tfs_fft** (*TimeFreqSupport*) -- Frequency domain timefreqsupport expected in
               output of fft.

   .. rubric:: Examples

   >>> from ansys.dpf import core as dpf

   >>> # Instantiate operator
   >>> op = dpf.operators.mapping.prep_sampling_fft()

   >>> # Make input connections
   >>> my_time_freq_support = dpf.TimeFreqSupport()
   >>> op.inputs.time_freq_support.connect(my_time_freq_support)
   >>> my_cutoff_frequency = float()
   >>> op.inputs.cutoff_frequency.connect(my_cutoff_frequency)
   >>> my_number_sampling_point = int()
   >>> op.inputs.number_sampling_point.connect(my_number_sampling_point)

   >>> # Instantiate operator and connect inputs in one line
   >>> op = dpf.operators.mapping.prep_sampling_fft(
   ...     time_freq_support=my_time_freq_support,
   ...     cutoff_frequency=my_cutoff_frequency,
   ...     number_sampling_point=my_number_sampling_point,
   ... )

   >>> # Get output data
   >>> result_time_tfs_sampled = op.outputs.time_tfs_sampled()
   >>> result_freq_tfs_fft = op.outputs.freq_tfs_fft()




.. py:currentmodule:: prep_sampling_fft

Overview
--------

.. tab-set::




   .. tab-item:: Properties

      .. list-table::
          :header-rows: 0
          :widths: auto

          * - :py:attr:`~inputs`
            - Enables to connect inputs to the operator
          * - :py:attr:`~outputs`
            - Enables to get outputs of the operator by evaluating it



   .. tab-item:: Static methods

      .. list-table::
          :header-rows: 0
          :widths: auto

          * - :py:attr:`~default_config`
            - Returns the default config of the operator.





Import detail
-------------

.. code-block:: python

    from ansys.dpf.core.operators.mapping.prep_sampling_fft import prep_sampling_fft

Property detail
---------------

.. py:property:: inputs

   Enables to connect inputs to the operator

   :returns: **inputs**
   :rtype: InputsPrepSamplingFft

.. py:property:: outputs

   Enables to get outputs of the operator by evaluating it

   :returns: **outputs**
   :rtype: OutputsPrepSamplingFft




Method detail
-------------

.. py:method:: default_config(server=None)
   :staticmethod:


   Returns the default config of the operator.

   This config can then be changed to the user needs and be used to
   instantiate the operator. The Configuration allows to customize
   how the operation will be processed by the operator.

   :param server: Server with channel connected to the remote or local instance. When
                  ``None``, attempts to use the global server.
   :type server: server.DPFServer, optional





